* session: keep after browser refresh.
  > except if expired!
* expire session: check in upload-start-script if session is expired.
  > if not expired, rewrite session with new expiration time.
* graceful error if session is invalid (expired, not exists, ...)

* replace strings with string_view, which are slices of existing strings.

* Save to cloud (via functions?)
  > cloud architecture: https://www.youtube.com/watch?v=JbEiek3MNWw
  > https://cloud.google.com/functions/docs/writing/http
  > depencencies for cloud functions in package.json : https://cloud.google.com/functions/docs/create-deploy-http-nodejs
  > Via Storage: use generateDownloadUrl
  > https://stackoverflow.com/questions/49201011/can-a-cloud-function-read-from-cloud-storage
  > functions to storage example in python: https://stackoverflow.com/questions/52249978/write-to-google-cloud-storage-from-cloud-function-python
  > Authenticate Client (Bearer token) via javascript: https://cloud.google.com/endpoints/docs/frameworks/python/javascript-client
  > Authenticate Storage via Function? : https://cloud.google.com/functions/docs/samples/functions-bearer-token
  > Local development: https://cloud.google.com/functions/docs/local-development
  > Using Firestore: https://www.youtube.com/watch?v=Z87OZtIYC_0&t=288s
    > perhaps for session data?
  > free hosting + domain: https://www.youtube.com/watch?v=cG9kv5-5bPI

* Tests: include more complex tests with multi-line code, like function defs.
* functions:
  > allow last ';' to be elimited.
  > fix all the TODO's, because quick-and-dirty code.
* optimize large programs
  > perhaps only one json stringstream? Via a Visitor?
* startup script
  > runs before every other run.
  > could contain functions and defs of vars,...

* create prime() function -> prime factorisation.
  > Can MathParser solve : https://www.youtube.com/watch?v=vhc4FceGjC8

* Move project from WPF folder to C++ folder.
* var.fragment=x; --> gives error: unexpected ';'. Should be "can't assign to..."

* Ambiguous:
  : DURATION.days -> fragment?
  : DURATION.days -> conversion?
  > do conversion another way?
    > DURATION -> NUMBER = seconds
    > How? Syntax?
      : to_days(DURATION)
      : DURATION->days
      : DURATION.as_days <<< my preferred solution. Just use fragments. No new notation. only as_days and as_seconds. Other resolutions can be derived via units.
      : (days)DURATION
      : Duration.s ? But duration will have a DURATION.seconds fragment...difference between .seconds and .s is confusing - too subtle.

* date fragment as hls should give error
    : today.year = 2022; //error!
* Date parsing;
  - return warnings if assumptions (ymd?) are being made.
* Duration calculations work!
  - separate fields for all fragments
  - parser (already in progress)
  - operators for what...works
* myDate + 1y
  > y unit
* test chrono with both MSVC and EMCC
  > not everything is implemented.

* npm scripts that start with a dot:
https://stackoverflow.com/questions/50998089/running-npm-script-on-windows-starting-with-a-period

* implicit mult with power: precedence changes depending on order?
  > 2^3b  =  2^(3b) >> mult has prio
  > 2b^3  =  2(b^3) >> power has prio

GUI
---
3 possible GUIs:

1. Current one (code left, output right or bottom) --> desktop + mobile.
2. Code right, output left --> desktop only?
  > the output could be really small column if echo (!) is ignored.
  > align output with input
    * Output to left of input
      > #txtOutput .CodeMirror {  text-align: right!important;  }
      > option to 'mirror' the lines or to collapse (remove) empty output lines

3. Command line.  --> desktop + mobile.
   > like mathlab.
   > actually perhaps preferred for mobile...
   > ignore echo?


Nice to have
---------------
* units :
  > mathlab not compact enough:
    https://nl.mathworks.com/help/symbolic/units-of-measurement-tutorial.html
  > complex units.
    > if you set a unit to a var BEFORE an equation:
      > when the eq is assigned to the var, a warning should be generated if the unit changes. (this allows for checking the physical dimension of your eq.)
  > custom units
    : basket = 10"apples";
    : sack = 20"pears";
    : basket+sack; //warning: units don't match
* dates:
  > goal: calculate age
    > age = (now()-birthdate).years; // -> subtraction is a duration.
    > age before end of year = <last_day_of_this_year> - birthdate;
    > how to get last day of this year based on now()?
      > trunc(now(), 'year') + 1 year - 1 day;
      > create new date in yy:mm:dd format: now().year:december:last
        > is this format with the colon unambiguous?
        > new keywords:all months, all days, and 'last' (and 'first'? No! First is alwayt 1)
        > is it always clear if we're talking about the last day or the last month?
        > 10:11:12 > always interpreted as yy:mm:dd
        > (10:11:12).year , ...and other fragments.
      > 'last'
        > can perhaps be kept for as long as possible in calculations that result in a different month? or in februari of a different year, and thus a different last day?
        > how to display 'last' in output?
          : februari 28(last) --> this version seems more intuitive to read, yet fairly short.
          > feburary 28 (last day) --> too long
          : februari 28.last  --> postfix notation? Feels like a subfield...
          : 2022:february:last(28) -> this could be both input syntax as output syntax, with or without the (28), which could be ignored when added to the input.
          
  > Date notation
    > if dd or mon are <= 12 -> error ambiguous.
    > always allow yyyy mm dd
    > #define date_format MDY | DMY  (YMD is always allowed)
    > date seperators: '/' '-' ' ' ','
    > month can be written in number, abbrev and full.

  > Value is currently only numeric.
    > Dates and numbers can not be calculated with directly: now() + 5 ? Five what? days? hours?
    > Analize a complexer expression with date stuff. See how it unravels and how to resolve it.
      : elon_time = now() + ((timepoint - timepoint).hours * big_integer)
      > timepoint = timepoint + [ (timepoint - timepoint = duration).hours = duration_in_unit_hours * number ]
      > basic expressions:
        - assign timepoint
        - timepoint operator- timepoint ==> duration // note that only the minus operator makes sense. See chrono for all operators.
        - duration operator* int



    > since dates are so different from numeric values, they require seperate classes, with their own resolvers and operators.
      > timepoint : UTC ( or system?) date.
      > duration : contains a numeric value and a 
      > calendar : a timepoint in it's individual components
        > Do we really need Timepoint? All dates can be represented in Calendar, no?
    > Value must have a type field: number, timepoint, duration, calendar,...
    > How to avoid a code mess in Resolver?
      > A resolver per type?
      > Or Keep a general resolver, and create a Calculator per type?
      > An expression can contain sub parts for other value types.
        > elon_time = (timepoint - timepoint).hours * big_integer.
    > any value can suddenly be turned into a date fragment:
      (a*5+2)hours;
    > so, fragments are ordinary Values with a unit.
    > how about dates?
    > You can't add dates:
      yesterday + today = nonsense;
    > but dates can still be used in expressions:
      lastMonday = today-3days; --> <date> = <date> op <value>
  > only once units and conversions/fragments are implemented.
  > x = '12/12/2022 23:45:11'; --> allow all parsable dates, unless ambiguous.
  > time-span: date - date -> timespan
  > now() function
  > fragments:
    > x = now().year
    > .year, .month,... 
      > are all integers, as decimals are confusing? 
      > warning when stripping a decimal part? Suggesting conversion to a lower type?
      > complex calculation:
        > (1hour/2)*4 = 2hours !! thus, no warning needed!
        > only warn about rounding at the end result
          > when assinging to  var
          > when converting to other unit.
  > half a minute?
    > 1min.sec/2 => 30sec 
    > imin/2 => omin !!!
  > data types:
    > see chrono lib
    - timepoint (don't use 'date' as this will be a unit for timepoint truncated to only the date part)
      > representation? readable date with or without time?
      > depends on unit:
        - date: only date
        - dt (or datetime?): plus time
        - time: 
          > does this make sense?
          > a time is perhaps only a duration?
          > when a 
    - duration:
      > units
        > singular and plural can be used - same meaning.
        - day, month, year, hour, minute, second
        - short version: dd, mon (mm = millimeter), yy, hh, min, ss
        Timepoints
Time_point<utc_clock> now = …;
Now():
Std:chrono::steady_clock::now() -> time_point<steady_clock>
Std:chrono::utc_clock::now() -> time_point<utc_clock>

Duration
Duration = now() - then();
Durations allow calculations and max(), floor(),…
Floor is template: floor<Sec>(duration);

See duration doc for conversions with or without precision loss, float or int.
Duration_cast<hours> from_duration to_duration: so, duration are of a type? Probably not. Cast is needed for durations of INT type. The cast defines the resolution, I guess.
Duration without cast: duration<double, millis>
So, I guess for a duration<int, sec> a duration_cast<sec> is needed?

  > units (fragments):
    >
  > conversions:
    - UTC
    - GPS
    -...
* Implicit variable:
    Implicit var _ always contains the last result (being the result of the previous statement)
    10+20+30;
    +40: //add to the result of the previous line.
    But what if:
    A=10;
    +20;//add this to A or only to implicit var or error? -> no error. Add to Implicit result.
    B=50;
    +=30; //add to var of previous line.
    +=40;// continue adding…

    C=_; //underscore is implicit var. Assign last value to C, which is B in this case;
    70;
    D=_;//D = 70

* custom functions
* resolve equations
* Variable ranges and wildcards
    Sum(a..z) : // sum all vars a to z
    Sum(a*); sum all vars that start with a; -> ambiguous syntax
    Sum([a*]);
    Ranges: always use [] ?
    Allow both (a..z) and ([a..z])

* simplify
* Latex visualisation

Voor eigen gebruik: online storage?
Of via localStorage: “Save as, in local browser”.
En ook klassieke “Save as” en “Open” en “New”, …

* drag en drop file on textarea?
* Save and open? 
  > unlikely, as this violates the browser sandbox.
  > download and upload: yes.
    > requires active webserver.

